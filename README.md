# Glimmer-CS--EASY---03-
#CS-easy-03
##第一题  

1.‌栈溢出是指程序在运行过程中，向栈中某个变量写入的字节数超过了该变量本身所申请的字节数，导致与其相邻的栈中的变量的值被改变。应该是由于缓冲区溢出而导致的。  

2.栈区的内存分配是由编译器自动管理的，当函数调用时，系统会自动为函数内的局部变量和参数分配栈空间，函数执行完毕后，这些空间会自动释放。堆区的内存分配是由程序员手动控制的，程序员需要负责在不再需要内存时显式释放，否则可能会导致内存泄漏。栈区的分配和释放效率更高但空间更小，但堆区若没有及时释放会导致后续的内存分配效率下降。  

3.在程序运行过程中，内存模型中的代码区、常量区和字符串常量区是只读的，而栈区、堆区、全局区（包括静态存储区）是可读写的。  

4.（申请内存的变量的类型）malloc（申请的空间大小），通常会在后一个括号中用sizeof，free（变量名称），就能将申请的内存还给计算机，它们主要对堆区进行操作。  

5.我认为可以提高系统性能，优化内存的使用，提高系统的整体性能，让程序能够稳定运行，也能实现公平的内存分配，，进而实现虚拟内存管理来提高系统的灵活性和效率。  

##第二题  

constValue：在定义时，使用了const，而其本身也是储存的int类型值，所以它位于常量区。在声明这个对象时，我们的目的就是保证它的值不会被修改，如果它储存在了其他区中，那就无法保证它的值不会改变，进而违背了初衷。  

constString：定义时使用了const和char*，它储存的是字符串，所以它属于常量字符区。字符串本身就不同于值，它不能储存在其他区域，否则该区的储存就会显得混乱（猜的），在调用时可能会出现错误。  

globalVar：它没有定义在函数内部，是全局变量，所以它属于全局区。在函数之外声明该变量，本身的目的就是能在不同的函数中使用它，并让它的值随着使用而改变，位于其他区则无法保证每次都能被调用。  

staticVar：它声明时在前面加了static，说明它是静态，所以属于静态区。该变量位于main函数之中，加static是想让该变量能一直存在，但又只能在main中访问，若位于栈区中，则无法保证能一直存在。  

localVar：它声明在了function函数类，是局部变量，属于栈区。该变量位于函数内，是临时变量，其生命周期只有从函数的开始到结束，每次调用又重新产生，若位于堆区则不能自动进行销毁，会一直占用内存，会造成内存损耗，位于静态区又会导致与原本目的相悖，会一直存在。  

ptr：指针本身应该是属于栈区，但此处它指向malloc申请的内存区域，堆区。指针只是承担一个向导的作用，可以导出它所指向的区域，使用指针的目的就是为了方便，在想用的时候就能调出它所指的区域，此处位于栈区就够了。  

localVarMain：声明在了main函数中，是局部变量，属于栈区。在main中声明，说明本身就是只想在main中使用，若位于全局区，其他函数中可能会有同名变量，就会导致它的值发生错误的改变，所以位于栈区，及时产生并使用就好。  

##第三题  

一.冯诺伊曼体系是现代计算机的基本模型，由存储器、CPU、输入输出设备和总线组成。现代计算机是基于冯诺伊曼体系建立的，它有层次化存储结构、流水线技术、超标量处理、分支预测和推测执行、多核架构、硬件线程，并改进了存储器层次结构。
###不同  

1.冯的程序和数据都存储在主存之中，而现代则引入了多级存储器层次，如缓存，磁盘等，数据能在不同存储器件移动，冯的设计让存储空间显得相当混乱，出现错误的可能也更大，而现代有虚拟内存和内存保护机制，让程序和数据安全独立地运行，冲突的可能更小。  

2.冯的CPU是逐条执行存储器指令且每次只执行一条，还要等待数据的传输，因为只有一个CPU和一个处理核心。现代则可以同时处理多条指令，能并行执行，因为现代都是多核多线程。  

3.冯的数据传输时会出现处理器和存储器之间的数据传输速度不匹配的情况，降低了CPU的性能，也降低了计算机的性能也就是冯诺伊曼瓶颈（搜的）。而现代则有多级缓存，双通道内存器等技术，还有更复杂的总线设计，都让这一情况有所缓解。

二.存储时CPU将要存储的数据位置通过地址总线发送到主存储器的某个存储单元中，CPU再通过数据总线将数据传到存储单元中。读取时首先CPU发出读命令等控制信号，将存储单元的地址通过MAR传输到主存中，主存在根据地址找到存储单元，将数据通过数据总线传输到MDR，再传到CPU处理。

三.cache的局部性原理是把程序中正在使用的部分存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行来提高程序执行速度。它包括了时间局部性和空间局部性。时间局部性就是一个数据或指令被访问过，那么近期可能还会被访问，那么缓存就会保存他们，来提高效率。空间局限性就是某个数据被访问后，它附近的数据近期也可能被访问，所以缓存也会预加载它们。
四.我认为这就是在一定程度上缓解了冯诺伊曼瓶颈的原因，它提高了存储器的速度，减少了CPU的等待时间，而这就与其局部性原理的引用有关，再加上多级缓存的运用，L1、L2、L3的分层结构最大限度地利用了缓存的速度和容量，也让多线程任务进行时有更高的效率，此外还减少了对主存储器，减缓了内存带宽压力。
